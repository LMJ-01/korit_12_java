# 금일 정리 목록

# Array
- random.nextInt();
    - argument가 없을 때는 가장 작은 정수부터 가장 큰 정수(int 범위 내) 중 하나를 임의 생성함.

- random.nextInt(한계값);
    - argument가 하나 있을 때는 한계값을 설정합니다. 근데 0을 포함하기 떄문에 random.nextInt(10);이라면 0 ~ 9까지의 범위에서 생성합니다.


- 생각해볼 점 : 1부터 10까지의 범위로 만들고 싶다면?

```java
for (Integer number : numbers) {
            number = random.nextInt(10) + 1;    // 1부터 10까지의 범위를 만들기 위해서.
            number *= 10;
            System.out.println(number + " / ");
        }
```

# 다차원 배열

1. 다차원 배열(Multi-Dimensional Array) 중에서 2차원 배열 :
    - 다차원 배열은 2 차원 이상의 배열을 의미하지만 개발 환경 상 2차원 배열 이상을 다루는 경우는 드물기 때문에 2차원 배열을 기준으로 강의.

-  형식 :

    1. int[][] arr01 = new int[크기][크기];    - 선언 방식 # 1

    2. int[][] arr02 = new int[크기][];       - 선언 방식 # 2

    3. int[][] arr03 = {{1, 2}, {3, 4}, {5, 6}}       - 선언 방식 # 3 및 초기화

    - 2차원 배열 선언 시, '열'의 크기는 지정하지 않아도 되지만 '행'의 크기는 항상
    지정해야함. 
    - -> 2 번 방식을 의미합니다.


```java
        1열 2열 (column)              - 세로줄을 열
    {    ↓  ↓
        {1, 2},     → 1 행 (row)      - 가로줄을 행
        {3, 4},     → 2 행 (row)
        {5, 6}      → 3 행 (row)
    }
```

```java
public class Array13Multi {
    public static void main(String[] args) {
        int[][] arr03 = {{1, 2}, {3, 4}, {5, 6}};

        // 5라는 숫자를 출력해보고 싶다.
        System.out.println(arr03[2][0]);
        // 2차 배열은 내부 element가 배열이라는 점에 주목한다면
        System.out.println(arr03);      // 결과값 : [[I@36baf30c
        System.out.println(arr03[2]);   // 결과값 : [I@7a81197d

        System.out.println(Arrays.toString(arr03));
        // 결과값 : [[I@5ca881b5, [I@24d46ca6, [I@7a81197d]

        // 2차 배열의 element 추출 -> 충첩 for문을 사용하는 것
        for (int i = 0; i < arr03.length; i++) {
            // 근데 내부가 1차 배열이기 때문에 평소에 쓰던 반복문을 또 써야 함
            for (int j = 0; j < arr03[i].length; j++) {
                System.out.print(arr03[i][j] + " / ");
            }
            System.out.println();
        }

        for (int i = 0; i < arr03.length; i++) {
            // 여기가 1차 배열이라고 했으니까
            System.out.println(Arrays.toString(arr03[i]));
        }

        // 근데 어제 배운거 복습 좀 하겠습니다.
        // arr03을 향상된 for문을 통해서 출력하는데
        // 1 - 2 -
        // 3 - 4 -
        // 5 - 6 -
        // 으로 출력하도록 작성하시오.

        // 주의 사항은 아까 말한 것처럼 for문 내부의 자료형이죠.
        // 예를 들어 int[] 배열의 내부 element의 자료형은 int입니다.
        // 그러면 int[][]의 내부 element는 ? -> int[] 겠네요. 그부분을 고려하겠습니다.
        for (int[] firstArray : arr03) {
            for (int secondElement : firstArray) {
                System.out.print(secondElement + " - ");
            }
            System.out.println();
        }
    }
}
```

# 상속(Inheritance)
- 객 체 지향 프로그래밍(Object-oriented Programming : OOP)의 핵심 개념 중 하나로,
기존 클래스(부모(슈퍼) 클래스)의 field와 method를 재사용하여 새로운 클래스(자식(서브) 클래스)를 만드는 것을 의미함.

## 상속의 필요성
- 상속을 통해 공통적인 기능을 부모 클래스에 정의하고, 이를 '여러' 자식 클래스가 재사용가능
    - 동물(Animal) 클래스가 있고, 이를 상속 받는 개(Dog), 고양이(Cat) 클래스가 있다고 가정했을 때, 동물의 공통적인 field(이름 / 나이 등)와 행위-method(걷기 / 먹기 등)을 부모 클래스에 정의하고, 개와 고양이는 각각 고유한 특성(짖기 / 우다다다 등)을 추가할 수 있음.
- 이상의 과정을 거쳤을 떄 얻을 수 있는 이점 :
    - Dog에 이름 / 나이 / 걷기 / 먹기 / 짖기를 정의하고,
    - Cat에 이름 / 나이 / 걷기 / 먹기 / 우다다다를 정의하는 등의 공통된 부분을 정의하는 일 없이 고유 속성 및 method만 정의하면 됨
    - 결과적으로 _중복된 코드를 줄일 수 있다_

## 상속의 특징

1. 단일 상속
    - Java는 단일 상속만 지원함. 하나의 클래스는 한 번에 하나의 부모 클래스만 상속 받을 수 있어 상속 구조가 간단하고 명확함.

2. super 키워드
    - 클래스의 생성자 및 setter에서 학습한 this와 유사한 개념으로 부모 클래스의 field에 접근하거나 부모 클래스의 생성자를 호출하거나 / 메서드를 호출할 때 사용(두 가지 사용법이 있습니다 - 추후 설명)

3. _method override_
    - 자식 클래스에서 부모 클래스의 기본 동작을 `재정의`할 수 있음. 이를 통해 자식 클래스는 부모 클래스의 기본 동작을 자신만의 방식으로 변경 가능.
    - 예시
        - Animal 클래스의 걷기 method를 Dog가 상속받고, _네 발로 걷기_ 로 재정의하고, Human 클래스가 method를 상속 받고 _두 발로 걷기_ 로 재정의가 가능합니다.
    
4. final 키워드 : 클래스에 final이 붙으면 상속 불가

5. method에 final이 붙을 경우에는 method override가 불가능

## 장점

1. 코드의 재사용성
    - 동일한 코드를 반복적으로 작성할 필요 x

2. 유지 보수의 용이성
    - 부모 클래스의 변경 사항이 자식 클래스에 자동으로 반영되기 떄문에 위계를 파악한 후에 수정하시면 됩니다.

3. 객체 간 관계 표현
    - IS-A 관계를 명확히 나타냄.
        - IS-A : '개'는 '동물'의 일종이다. 와 같은 예시로 IS-A는 is a kind of의 축약어에 해당함.
        - 그래서 우리가 미리 만들어둔 Animal / Tiger / Human 클래스를 예로 들었을 떄, Human / Tiger는 Animal 클래스의 자식(서브) 클래스이다. 라고 해석할 수 있습니다.

        - 좀 더 일반적이고 넓은 범위를ㄹ 가지는 것이 부모 클래스가 될 것이고, 좀 더 구체적이고 특징지어진 것이 자식 클래스가 될 것입니다.

## super 키워드

1. super() : 부모 클래스의 생성자를 호출

2. super.메서등명() : 부모 클래스의 메서드를 호출

-  @Override가 되어있는 부분은 상위 클래스로 부터 상속 받은 메서드임을 의미함.

- 그러니까 얘가 아예 없으면 고유 메서드라는 뜻일 것이고, 클래스에 없는 메서드를 호출한다면 부모 클래스의 메서드를 '그대로' 쓰는 거고 @Override가 있다면 부모 클래스의 메서드를 호출하긴 하는데, `'재정의'` 가 되어있다고 볼 수 있음.

## 상속 관계
- 부모-자식의 상속 관계가 성립되어 있을 떄, 부모 클래스에서 기본 생성자 없이 매개변수       생성자만 있다면, 자식 클래스에서 완벽한 기본 생성자를 만드는 것이 '불가능'합니다.
    - 자식 클래스의 객체를 생성 시 필수적으로 '부모 클래스의 생성자를 호출'하기때문입니다.

- 자식 클래스에서 정의도지 않은 일부 필드와 메서드를 어떻게 사용할 수 있냐면 부모 클래스의 객체를 생성한 다음에 자식 클래스에서 고유 필드와 메서드를 더하여 합치는 과정을 거치기 때문입니다.
./
- 그래서 부모 클래스의 생성자 정의 방식을 따르지 않으면 자식 클래스에서 오류가 발생하는 경우가 있습니다.

- 또한 어떤 객체를 생성할 때 저희는
    - A a = new A(); 방식으로 생성해왔는데 앞으로는
    - A a = new B(); 같은 방식으로 생성하는 내용이 있을 겁니다. -> 정처기 단골문제