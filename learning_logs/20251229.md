# 금일 정리 목록 =.=

## Java Review
1. 자료형(type)
    1. 기본 자료형(Primitive Types)
        1. 숫자 관련
            - 정수 관련
                - int, long
            - 실수 관련
                - double, float
            왜 두개씩 있나? : 용량 문제 ch04_conversion 확인
        2. 문자 관련
            - 문자(char)
    2. 참조 자료형(Reference Types)
        1. 문자 관련
            - 문자열(String) : 문자가 '순서대로' 나열 되어있다는 점.
                - 안근수 / 수근안 : 동일한 문자들로 구성되어있지만 순서가 다르기 때문에 차이가 있음.
                - 안 + 근 + 수 / 수 + 근 + 안의 결과값이 다릅니다.
                - 숫자의 경우에는 1 + 2 + 3 / 3 + 2 + 1이 결과값이 동일한 것과는 차이가 있습니다.
2. 변수(Variable) : 데이터(값)를 담는 바구니(인데 이름을 붙여줘야 함).
    1. 변수 명명 규칙
        - camel case를 사용할 것.
            - camel case : 시작은 소문자로, 다수의 단어로 이루어졌을 경우 두 번쨰 이후 단어의 첫 번째 알파벳은 대문자로 입력할 것.
            - 예시 :
                - 단수 단어 : result
                - 복수 단어 : myTestResult
            - Pascal case : 시작을 대문자로, 다수의 단어로 이루어졌을 경우 두 번쨰 이후 단어의 첫 번쨰 알파벳은 대문자를 입력할 것, 나머지는 소문자.
                - Pascal case는 클래스 명명 규칙에 해당합니다.
            - 예시 :
                - 단수 단어 : Result
                - 복수 단어 : MyTestResult
    2. 변수 선언 및 초기화
        - 자료형 변수명 = 데이터;

```java
public static void main(String[] args) {
    // 자료형 변수명 = 데이터;      -> 주석 다는 방법도 했었네요.
    int age = 20;

    // 변수 선언 : 앞으로 해당 변수가 사용될거라는 것을 선언(declaration)
    String name;
    // 초기화 : 특정 변수에 처음으로 값을 대입하는 것.
    name : "김일";
    // 재대입 : 특정 '변수'에 값을 바꿔주는 것.
    name : "김이';
}
```

 3. 상수 : 데이터가 초기화 이후 재대입이 불가능한 변수를 의미함.

```java
public static void main(String[] args) {
// final 자료형 변수명 = 데이터;
    final int age = 12;     // 상수라는 것을 알리기 위해서 camel case를 쓰지 않고 대문자로 작성함.
    // age = 13;    - 재대입하려고 하면 오류가 발생함.
}
```

- 상수 명명 규칙
    - camel case를 적용하지 않고 전부 다 대문자로 작성함. 복수 단어로 이루어져있을 경우 단어 경계에 언더바(언더스코어 : '_')를 사용.
        - 예시 :

            1. 단수 단어 : RESULT

            2. 복수 단어 : MY_TEST_RESULT

3. Conversion(형변환) : 특정 변수(객체)를 다른 자료형으로 변환시키는 것.

    1. upcasting : 특정 변수(객체)를 더 큰 용량의 자료형으로 변환시키는 것.

        - 암시적(implicit)으로 이루어짐 : 작은 용량에서 큰 용량으로 변환 시킬 떄는 데이터의 값이 변질되지 않기 떄문에 직접적으로 바뀔 자료형을 명시하지 않아도 됨.

    2. downcasting : 특정 변수(객체)를 더 작은 용량의 자료형으로 변환시키는 것.

        - 명시적(explicit)으로 이루어짐 : 더 큰 용량에서 작은 용량으로 바꾸게 될 경우 용량 제한으로 인해 데이터의 값이 변질될 수 있기 떄문에 직접적으로 자료형을 명시해야만 함.
```java
public static void main(String[] args) {
    // 변수 선언 및 초기화
    char cast1 = 'A';

    // 1. 업캐스팅 # 1 : (바뀔데이터타입)변수명;
    System.out.println("변형 : " + (int)cast1); // 결과값 : 65
    // 2. 업캐스팅 # 2 : 변수 새로 선언해서 대입하는 방식
    int casted1 = cast1;    // 이 부분이 '암시적(implicit)'

    // 다운캐스팅 용 변수 선언 및 초기화
    int cast2 = 97;
    // 3. 다운캐스팅 # 1 : (바뀔데이터타입)변수명;
    System.out.println("변형 : " + (char)cast2); // 결과값 : a
    // 4. 다운캐스팅 # 2
    char casted2 = (char)cast2;     // 이 부분이 '명시적(explicit)' - 업캐스팅 # 2와의 차이점 확인하세요.
}
```

4. Operator(연산자)
    1. 대입 연산자 '=' : 왼쪽에 있는 변수에 '=' 오른쪽에 있는 데이터(값)를 '대입'한다는 의미 - 즉 a = b라고 했을 떄 a 와 b의 값이 값다 라는 의미가 아니라는 점에 주목해야 합니 다.
        - 같다고 이야기 하고 싶다면 '=='을 씁니다. 근데 JavaScript에서는 '=='도 있고 '==='eh 있습니다.
    2. `+ - * / ` : 수학이랑 똑같습니다. - 문자, 문자열 자료형의 경우에도 + 연산자는 적용이 가능.
    3. % : 나머지 연산자 - 나누고 나서 남는 나머지를 명시함. 즉 결과값은 int, long이어야 함.
    4. 복합대입연산자
        1. +=
        2. -=
        3. *=
        4. /=
    5. `++ / -- `
```java
public static void main(String[] args) {
    int num = 1;
    System.out.println(num++); // 결과값 : 1
    System.out.println(num);   // 결과값 : 2
    System.out.println(++num);   // 결과값 : 3
    System.out.println(num);   // 결과값 : 3
    System.out.println(num--);   // 결과값 : 3
    System.out.println(num);   // 결과값 : 2
    System.out.println(--num);   // 결과값 : 1
}
```
5. condition(조건문) : 조건식 내의 return값이 true / false에 따라서 특정 부분을 실행시키는 제어문
```java
public static void main(String[] args) {
    if(조건식1) {
        실행문1-1
        if(조건식1-a){
            실행문1-a
        } else if(조건식1-b) {
            실행문1-b
        } else if(조건식1-c) {
            실행문1-c
        } else {
            실행문1-d
        }
        실행문1-2
    } else if(조건식2) {
        실행문2-1
        if(조건식2-a){
            실행문2-a
        } else {
            실행문2-b  
        }
        실행문2-2
    } else {
        실행문3
    }
}
```
1. 용어 정리
    1. 조건식 : true / false로 결정이 날 수 있는 boolean 자료형을 return하는 식

    2. 실행문 : if, else if, else 이후의 {} 내의 영역으로 특정 조건을 만족했을 경우 실행되는 코드 혹은 식.

2. 반복문과의 유의 사항
    - 반복문은 특정 조건을 만족했을 경우 '반복'실행되는데 반해, 조건문은 해당 조건에 해당되는 부분을 '한 번' 실행됩니다. 그래서 if-else if else 전체를  한 세트로 봐야 합니다.
3. switch문
```java
public static void main(String[] args) {
    // 사용할 클래스 import
    Scanner scanner = new Scanner(System.in);
    // 변수 선언 및 초기화
    int menu = 0;

    System.out.println(" [ 메뉴 선택 ]");
    System.out.println("1. Java 공부하기");
    System.out.println("2. JavaScript 공부하기");
    System.out.println("3. Python 공부하기");
    System.out.println("4. HTML 공부하기");
    System.out.println("5. Big Data 공부하기");
    
    System.out.print("메뉴를 선택하세요 >>> ");
    menu = scanner.nextInt();

    switch(menu) {
        case 1:
            System.out.println("Java를 공부하기로 하셨습니다!");
            break;
        case 2:
            System.out.println("JavaScript를 공부하기로 하셨습니다!");
            break;
        case 3:
            System.out.println("Python을 공부하기로 하셨습니다!");
            break;
        case 4:
            System.out.println("HTML을 공부하기로 하셨습니다!");
            break;
        case 5:
            System.out.println("Big Data를 공부하기로 하셨습니다!");
            break;
        default :
            System.out.println("오늘은 쉬기로 결정했습니다.");
    }
}
```
6. Loop(반복문)
    1. while
``` java
public static void main(String[] args) {
    int i = 0;
    while( i < 100) {   // () 내부의 조건식이 true일 때 실행 - 무한 루프를 조심해야 함.
        if ( i % 2 == 0 ) {
            System.out.println(i + " 는 짝수입니다.");
        } else {
            System.out.println(i + " 는 홀수입니다.");
        }
        i++;        // 특정 조건에서 while 반복문을 탈출하기 위해서 통제할 필요가 있음.
        System.out.println("다음 숫자로 넘어갑니다.");
    }
}
```
2. for
``` java
public static void main(String[] args) {
    // for ( 시작값 ; 한계값 ; 증감값 )
    for (int i = 0; i < 100 ; i++ ) {
        if ( i % 2 == 0 ) {
            System.out.println(i + " 는 짝수입니다.");
        } else {
            System.out.println(i + " 는 홀수입니다.");
        }
    }
}
```
3. 주의 사항
    - while문의 경우에는 무한루프에 빠지지 않도록 특정 조건 하에서 반복문을 탈출할 수 있게끔 작성할 필요가 있음.

    - for문의 경우에는 한계값을 초반부에 명시하고, 그 반복횟수를 int로 정리한다는 점을 생각해둘 것. while문의 경우에는 조건식이 String일 수도 있죠.

    증감값을 통해 반복횟수를 통제한다는 점에서,
        
    - while 문 : 특정 조건 하에서만 반복실행되게 통제 할 떄 사용.
    - for 문 : 명확한 반복 횟수를 통제할 떄 사용.

## 클래스 / 객체
1.  클래스
    1. 클래스란?
        객체를 생성하기 위한 설계도 = 틀 / 청사진
        현실 세계의 개념을 프로그래밍으로 표현할 떄,
        "특정 사물이나 개념의 특징(속성)"과 "행위(메서드)"로 정의함.
    2.  예를 들어,
        "자동차"라는 클래스를 생성한다면 자동차의 속성(색상, 속도)과,
        행위(가속, 정지 등)를 코드로 표현할 수 있음.

```java
public class ClassA {
    // 필드 / 인스턴스 변수 / 멤버 변수 / 속성 정의
    int num;
    String name;
    double score;
    // 이상의 코드에서 보시면 선언만 되어있고 초기화는 이루어지지 않았습니다.

    // 메서드 정의 방법
    // 접근제어자 리턴타입 메서드명(매개변수1, 매개변수 2) {
    //  실행문(method body)
    //  (return)
    // }
    public void callName() {
        System.out.println(name + "을 부릅니다.");
    }
}
```

2. 객체
    1. 객체(Object)란 ?
        클래스를 설계도로 가정했을 떄, 실제 사용할 수 있는 자동차(인스턴스)는 객체라고 함.
    2. Object와 Instance는 우리나라에서는 거의 동일한 용어로 사용됩니다.

- 객체와 인스턴스 관계
    1. 객체는 포괄적인 개념으로 클래스에서 생성된 모든 것을 객체라고 표현
    2. 인스턴스는 특정 객체가 어떤 클래스의 구현체인지 강조하는 표현

- 비유로 이해하기
    1. "사람"이라는 클래스가 있다고 가정한다면,
    2. "홍길동", "김철수"는 이 클래스에서 생성된 객체임. 근데 "아반떼"도 객체임
    3. "홍길동은" "사람"이라는 특정 클래스의 '인스턴스'임. 아반떼는 아님.

```java
public class ClassAMain {
    public static void main(String[] args) {
        // 객체 생성 방법
        // 클래스명 객체명 = new 클래스명();
        ClassA classA1 = new ClassA();
        Scanner scanner = new Scanner(System.in);

        // 필드에 값 대입하는 방법
        // 객체명.속성명 = 값;
        classA1.num = 1;
        classA1.name = "김일";
        classA1.score = 4.5;

        System.out.println(classA1.name + " 학생의 학번은 " + classA1.num + " 번 이고, 점수는 "
                + classA1.score + "점입니다.");

        classA1.callName();
    }
}
```
## method overloading
    
1. method overloading 이란?

    - 매개변수의 유무 및 자료형의 차이, 개수의 차이를 나눠서
    동일한 메서드 명을 지닌 메서드'들'을 정의할 수 있다.

    - 즉, 메서드 명은 동일하고, 매개변수에 들어가는 자료형, 개수를
    달리하게 되면 서로 다른 메서드로 인지하게 됩니다.

    - 예를 들어서 숫자끼리 더하는 메서드가 있다고 가정하겠습니다.
    걔를 add()라고 정했다고 칩시다.

```java
public int add(int a, int b) {
            return a + b;
        }

        //근데 문자열끼리 더하는 게 필요해서 add는 못 쓰니까 connect를 씁시다.
        public String connect(String a, String b) {
            return a + b;
        }

        //근데 뒤집어서 연결해야 할 때가 있어서
        public String connect(String a, String b) {
            return b + a;
        }

        //근데 정수 더하기 실수 해야해서
        public double plus(int a, double b) {
            return a + b;
        }

        //이런 부분이 문제가 됩니다.
```
    
2. method overloading의 장점
    - 동일한 기능을 하는 메서드를 정의할 때 메서드 명이 필요한데,
        예를 들어 String 자료형끼리 연결해주는 메서드와 int끼리의 합 연산을 하는 메서드를 나눈다고 가정했을 때,
        
        add,
        plus,
        connect 등을 정의했다면,
        다음 합 연산을 하는(예를 들어 double 자료형을 지니는) 메서드 명을 정하려고 하면 번거롭습니다.

        이러한 부분을

           public void add(String example1, String example2) {
               로직
           }

           public void add(int example1, int example2) {
               로직
           }

           public void add(double example1, double example2) {
               로직
           }

        과 같이 자료형을 달리 하는 '동일한 이름을 가지는 메서드들'을 정의하거나,

          public void add(double example1, double example2, double example3) {
               로직
           }
        와 같은 식으로 매개변수의 개수의 차이를 두더라도 '동일한 기능을 하는 서로 다른 메서드'들로 인식하게끔 하는 방식입니다.

        그러면 메서드 명들도 동일하고, 걔네가 뭐 매개변수 유형이가 개수가 차이가 있겠지만 기능도 같으니까 머리가 안아프다는 장점이 있다고 할 수 있습니다.

## 생성자(Constructor)
1. 생성자는 객체가 생성될 때 호출되는 특별한 '메서드'

    객체 생성 예시

        클래스명 객체명 = new 클래스명();

    ClassExample example = new ClassExample();

    - 사실 ClassExample() 가 생성자에 해당됩니다.

2. 특징
    1. 클래스의 이름과 생성자의 이름은 동일하다.
            (다른 메서드들과 달리 Pascal Case로 작성되죠,
            그리고 아까 수업에서 들었다면 method는 동사로 시작되는데,
            얘는 클래스 이름이랑 똑같으니까 명사겠네요)

    2. return 값이 없습니다. -> call1(), call2() 유형으로 생각할 수 있음.

    3. 객체 초기화 : 생성자는 객체의 필드 '초기화'를 담당한다.

3. 생성자 정의 방식
    1. 기본 생성자 : 매개변수가 없는 생성자
            (근데 얘는 클래스를 만들 때 default로 생성되기 때문에 정의하지 않아도
            될 때가 있습니다. 저희가 Car() 어쩌고 메서드를 만들지 않았죠)
            즉, default로 생성된 기본 생성자를 이용하여 객체를 생성했습니다.

    2. 매개변수 생성자 : 하나 이상의 매개변수를 가지는 생성자

```java
public class Constructor {
    // 필드 선언
    int num;
    String name;
    /*
        기본 생성자 정의 -> 원래 default로 만들어집니다.
        그리고 매개변수의 유무만 있고 return이 없어서 call1() / call2() 유형밖에 없죠
        그 말은 어차피 return 없어서 void니까 void를 명시하지 않습니다.
        그리고 기본 생성자는 매개변수가 없으니까 method 적으로는 call1()
        유형에 해당합니다.
     */
    public Constructor() {
        System.out.println("NoArgsConstructor(기본생성자)");
    }
    // 매개변수 생성자
    public Constructor(int number) {
        System.out.println("RequiredArgsConstructor(int 매개변수를 필수로 요구하는 생성자)");
        this.num = number;  // this : 해당 클래스에서 객체를 생성하게 되면 객체 이름으로 대체됨.
    }
}
```
```java
public class ConstructorMain {
    public static void main(String[] args) {
        Constructor constructor1 = new Constructor();
        Constructor constructor2 = new Constructor(2);
        System.out.println(constructor2.num);
        // 아까 전에는 myCar 객체를 생성하고 그 다음에 빨강이라는 값을 color에
        // 대입했습니다.
        // 근데 잘 생각해보면 아니 만들면서 곧장 color는 빨강라고 지정할 수 없는건가
        // 에 해당하는겁니다.
        // Car myCar = new Car("빨강");
    }
}

```