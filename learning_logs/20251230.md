# 금일 정리 목록

# rough schedule

 - 20260129  첫 시험 예정

    1. Java - 프로그래밍 언어 활용 / 프로그래밍 언어 응용
    2. HTML / CSS / JavaScript - UI 구현

# 클래스

```java
package ch08_classes.students;

public class Student {
    // 필드 선언 영역
    int studentCode;
    String name;
    double score;
    // 생성자 정의 영역
    public Student() {
        System.out.println("기본 생성자로 객체를 생성했습니다.");
    } // sout는 return하는게 아닙니다.
    // 매개 변수 생성자 # 1
    public Student(int studentCode) {
        System.out.println("int 매개 변수로 객체를 생성했습니다.");
        this.studentCode = studentCode;
    }
    // 매개 변수 생성자 # 2
    public Student(String name) {
        System.out.println("String 매개변수 생성자로 객체를 생성했습니다.");
        this.name = name;
    }
    // 매개 변수 생성자 # 3
    public Student(int studentCode, String name) {
        System.out.println("int, String 매개변수 생성자로 객체를 생성했습니다.");
        this.studentCode = studentCode;
        this.name = name;   // 매개 변수가 두 개이기 때문에 두 개의 field에 값이 대입되어야겠네요.
    }
    // 매개 변수 생성자 # 4
    public Student(int studentCode, String name, double score) {
        System.out.println("int, String, double 매개변수 생성자로 객체를 생성했습니다.");
        this.studentCode = studentCode;
        this.name = name;
        this.score = score;
    }

    // 메서드 정의 영역
    public void showInfo() {
        System.out.println(name + " 학생의 정보입니다.");
        System.out.println("학번 : " + studentCode);
        System.out.println("이름 : " + name);
        System.out.println("점수 : " + score);
        System.out.println();
    }
}
```
```java
package ch08_classes.students;

import ch08_classes.products.Product;

public class StudentMain {
    public static void main(String[] args) {
        Student student1 = new Student();
        // 기본 생성자로 만들었으니까 전체 필드에 값을 대입해야합니다.
        student1.studentCode = 2025001;
        student1.name = "김일";
        student1.score = 4.5;
        // 이까지가 student1 객체 생성과 필드에 값 대입 부분입니다.
        // 이하의 부분부터는 하나~ 세 개의 필드에 값이 이미 있는 상태로
        // 객체가 생성되겠네요. 그러면 0 ~ 2 개의 필드에 값을 대입하는 코드가
        // 있어야 할 것 같습니다.
        Student student2 = new Student(2025002);
        student2.name = "김이";
        student2.score = 100;

        Student student3 = new Student("김삼");
        student3.studentCode = 2025003;
        student3.score = 95.8;

        Student student4 = new Student(2025004, "김사");
        student4.score = 4.0;

        Student student5 = new Student(2025005, "김오", 80.7);
        System.out.println();   // 개행을 위한 sout

        student1.showInfo();
        student2.showInfo();
        student3.showInfo();
        student4.showInfo();
        student5.showInfo();

    }
}
/* 출력 값 :
기본 생성자로 객체를 생성했습니다.
int 매개 변수로 객체를 생성했습니다.
String 매개변수 생성자로 객체를 생성했습니다.
int, String 매개변수 생성자로 객체를 생성했습니다.
int, String, double 매개변수 생성자로 객체를 생성했습니다.

김일 학생의 정보입니다.
학번 : 2025001
이름 : 김일
점수 : 4.5

김이 학생의 정보입니다.
학번 : 2025002
이름 : 김이
점수 : 100.0

김삼 학생의 정보입니다.
학번 : 2025003
이름 : 김삼
점수 : 95.8

김사 학생의 정보입니다.
학번 : 2025004
이름 : 김사
점수 : 4.0

김오 학생의 정보입니다.
학번 : 2025005
이름 : 김오
점수 : 80.7
*/
```

- 👍 생성자를 Art + Ins 키를 누르면 더 편하게 생성가능

# Getter / Setter
## Getter / Setter의 필요성
1. 문제 상황
    - 클래스를 하나 만든다고 가정하겠습니다. 예를 들어 Person 클래스를 생성하면서, 이름, 나이 등의 정보를 저장하기 위해 field를 선언합니다.

```java
public class Person {
    // field 선언
    String name;
    int age;
}

public class PersonMain {
    public static void main(String[] args) {
        Person person = new Person(); // 이거 객체 생성한거죠.
        // 객체에 값을 대입하는 방법
        // 객체명.필드명 = 데이터;
        person.name = "김일";
        person.age = -10;

        System.out.println(person1.name);   // 결과값 : 김일
        System.out.println(person1.age);    // 결과값 : -10
    }
}
```
이상의 코드를 확인했을 떄, 나이가 정상적이지 않은 값이 대입되어있습니다. 이처럼 외부(다른 클래스)에서 직접 속성값을 대입하게 될 때, 이상한 값이 들어가더라도 통제할 수 있는 방법이 없다는 문제가 있습니다. -> 이를 해결하기 위한 방법이 getter / setter 개념입니다.

## Getter / Setter란 ?
1. Setter
    - 데이터를 '설정'하는 역할을 하는 'method.' 클래스 외부에서 필드를 직접 수정하지 못하도록 막고, 특정 메서드를 경유하여 값을 전달받아 '초기화 및 수정'을 하도록 함.

2. Getter
    - 데이터를 '조회'하는 역할의 'method.' 클래스 외부에서 필드를 직접 읽지 못하도록 막고, 특정 메서드를 경유하여 안전하게 값을 '반환(return)'하도록 함.
3. 장점 :
    1. 데이터 보호
        - 변수가 private 접근 제어자(추후 수업 예정)를 사용하여 외부에서 직접 접근하지 못하게 함으로써 데이터를 보호할 수 있음.
    2. 데이터의 유효성 검증(아까 -10 같은 데이터를 걸러내는 역할입니다)
        - setter 메서드에서 입력된 데이터가 접합한지 확인하고, 잘못된 값을 거절할 수 있음.
    3. 갭슐화(encapsulation)
        - 데이터를 숨기고 필요한 경우에만 제한적으로 접근할 수 있어 클래스 내부 구현을 외부로 노출하지 않음.
    4. 유연성 증가
        - 나중에 요구 사항이 바뀌어 데이터를 설정하거나 조회하는 방법이 달라지더라도 클래스(Main 말고) 내부의 메서드만 수정되면 되므로 유지 보수가 쉬워짐.

## Setter / Gatter의 구조
### Setter
```java
public void set속성명1(자료형 변수명) {
    this.속성명1 = 변수명;
}
public void setName(String name) {
    this.name = name;
}
```
```java
// setter는 method이므로 객체명.메서드명();
// setter를 경유하여 field에 값을 대입하는 방법
person1.setName("김일일");
person1.setAge(-100);
person1.setAddress("서울특별시 종로구");
```


### Getter
```java
public 자료형 get속성명1() {
    return 속성명1;
}
public int getAge() {   // field와 getter의 자료형이 일치해야 합니다.
    return age;
}
```
```java
// getter를 적용하여 field를 조회하는 방법
System.out.println(person1.getName());
System.out.println(person1.age);
System.out.println(person1.getAddress());
```

```java
// String / Scanner 등은 class에 해당합니다. 그런데 우리는 이미 class를 배웠으니까,
// 거기에 method들이 딸려있다는 것을 알 수 있습니다.
// 그리고 field도 있겠네요.

int lengthOfName = person1.getName().length();  // chaining method
System.out.println(lengthOfName);

// chaining method를 잘 적용하려면 특정 메서드의 결과값이 어떻게 되는가를 아는 것이 매우 중요합니다.

```
- 👍 마찬가지로 Setter / Gatte를 Art + Ins 키를 누르면 더 편하게 생성가능

# 접근제어자(Access Modifier)
## 정의
- 클래스, 필드, 변수, 메서드의 접근 범위를 제어하는 키워드
- 사용이유
- 정보 은닉(캡슐화 : encapsulation)을 실현하고, 코드의 보안성과 유지보수성을 위해.

## 접근제어자의 종류
1. public : 모든 클래스에서 접근 가능
    - setter / getter를 art + ins를 통해 생성하게 되면 public이라는 것을 확인할 수 있습니다. 애초에 다른 클래스(예를 들어 UnivStudentMain)에서 사용하라고 만든 것이기 떄문에 기본적으로 public에 해당합니다.

2. protected : 같은 패키지 내의 클래스 및 이 클래스를 상속 받은 자식 클래스에서 접근 가능(상속은 추후 설명)

3. default : 접근 제어자를 명시하지 않으면 default로 간주되며, 같은 패키지 내의 클래스에서 접근 가능

4. private : 같은 클래스 내에서만 접근 가능
    - 그래서 저희는 웬만하면 private 접근 제어자를 사용할 예정입니다.

```java
package ch10_access_modifier;
// 이하의 클래스는 default가 생략되어있겠네요.
class AccessModifierExample {   // 간판 클래스는 public이 명시돼야 함.
    // field 선언             - 필드긴 한데, 선언 및 초기화하겠습니다. 처음보는 예시입니다.
    public int publicVar = 10;
    protected int protectedVar = 20;
    int defaultVar = 30;
    private int privateVar = 40;

    public int getPrivateVar() {
        return privateVar;
    }
}

public class Main {
    public static void main(String[] args) {
        // 객체 생성 : default class니까 객체 생성이 가능하겠네요.
        AccessModifierExample example = new AccessModifierExample();
        // field를 조회하겠습니다.
        System.out.println(example.publicVar);
        System.out.println(example.protectedVar);
        System.out.println(example.defaultVar);
//        System.out.println(example.protectedVar); // private 접근 제어자이기 떄문에 오류 발생합니다. field의 직접 조회불가능
        System.out.println(example.getPrivateVar());
    }
}

```
# 내일 수업 예정
1. AccessModifier 복습
2. 배열(Array) / Lombok 라이브러리 적용