# 금일 정리 목록

# Object 클래스

- _모든 클래스는 Object 클래스를 상속_ 받는다. 그래서 interface를 implements 할 떄나 다른 서브 클래스를 만들어서 extends 입력했다고 했을 떄 우리가 직접 만들었던 슈퍼 클래스 이외에 alt + ins 눌러보면 toString() 어쩌고 한 메서드들이 추가되어있었습니다.

1. toString() : 기본적으로 모든 클래스는 Object 클래스를 상속 받아서 클래스 이름과 해시코드(일종의 주소지 개념)를 return함.

    - 이를 Override하여 재정의하고 클래스의 정보를 출력할 떄 사용함.

    - field를 정의하고, toString() 메서드를 override해서 필요한 field들을 출력함(name만 혹은 address만도 가능합니다). -> 추가적으로 객체의 이름만으로 출력이 가능하기 때문에

    `System.out.println(객체명.toString())`이 아니라,
    `System.out.println(객체명)`로 할 수 있습니다.

2. equals() : String에서의 두 객체가 '논리적으로 같은지'를 비교하는 메서드(주소지의 차이가 아니라). 기본적으로 Object 클래스의 equals() 메서드는 두 객체의 참조 주소를 비교합니다.

    - 형식 : 객체명1.equals(객체명2) : 객체명1과 객체명2의 참조 주소가 동일한지를 확인함.
        - 3형식 문장으로 해석하시면 됩니다 SVO.

3. hashCode() : 객체를 정수값(해시값)으로 변환(16진수가 아니라). 해시 값은 주로 해시 기반 컬렉션에서 사용됩니다(추후 사용).

    - equals() 메서드를 재정의하게 되면 반드시 hashCode() 메서드도 재정의해야만 합니다. 왜냐면 동일한 객체(equals == true)는 동일한 해시 코드를 가져야하기 때문인데, 문제는 해시 코드가 같다고 해서 또 equals()가 true가 아닌 경우가 있기 때문입니다.

# Lombok

- 좌측 상단의 메뉴바(햄버거) -> 설정 (ctrl + alt + s) -> 좌측에 plugins(플러그인) 선택 -> lombok 검색 -> 설치 후 disabled / 비활성화 라고 뜨면 롬복을 설치 후 활성화되었다는 의미입니다.

- Chrome -> mvn 검색 -> maven repositories 로 들어가서 lombok 검색 -> 웬만하면 최신 버전 -> 그리고 저희가 첫 날에 gradle에 grovy로 만들었습니다. -> 그래서 groovy short 복사한 후에
build.gradle로 가서 annotationProcessor도 빼먹지 말고 이하와 같이 추가해줍니다.

```java
dependencies {
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    implementation 'org.projectlombok:lombok:1.18.42'
    annotationProcessor 'org.projectlombok:lombok:1.18.42'
}
```

- 그리고 아무 클래스나 들어가서 `@Getter` 등을 입력했을 때 경로가 Lombok으로 나오면 적용이 성공했음을 알 수 있습니다.

## Lombok 주요 annotation

1. @Getter / @Setter

    - class level에 작성할 경우 모든 getter / setter 메서드를 자동 생성

    - field level에 작성할 경우 해당 field에만 메서드 생성

    - 주의 : 객체마다 다른 값을 갖게 되는 비정형(non-static) field에만 해당됨.

```java
@Setter
@Getter
public class Person {

}
```

2. @ToString

    - toString() 메서드를 자동 생성. 문제는 재정의가 안되고 Lombok 라이브러리 default 형태만 나오기 때문에 원하는 부분만 보여주기 위해서는 override 할 필요가 있습니다.

3. @EqulAndHashCode

    - equals() / hashcode() 메서드를 자동 생성. 객체의 동일성 비교 로직을 구현할 떄 사용.

        - 아까 학습한 것처럼 equals()를 재정의하면 hashCode()도 반드시 재정의해야하기 때문에 롬복에서는 세트로 묶어놨습니다.

4. @NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor

    - @NoArgsConstructor : 매개변수가 없는 기본 생성자를 생성

    - @RequiredArgsConstructor : final 또는 `@NonNull` 애너테이션이 붙은 field만 필수적으로 요구하는 매개변수 생성자를 생성

    - @AllArgsConstructor : 모든 field를 argument로 요구하는 매개변수 생성자

5. @Data

    - @Getter / @Setter / @ToString / @EqualsAndHashCode / @RequiredArgsConstructor가 다 들어가있는 종합 패키지 애너테이션.

6. @Builder 

    - 추후 수업 예정

# Static

## 정의

- 클래스 수준에서 변수를 정의하거나 메서드를 선언할 떄 사용

- static으로 선언된 변수나 메서드는 클랫의 '인스턴스에 속하지 않음.'(즉 객체마다 다른 값을 가지는 것이 인스턴스변수였는데, 그게 아니라 해당 클래스의 인스턴스가 전부 동일한 값을 공유함을 의미합니다)

- 클래스 자체에 속하게 됨.

- 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 field, method와 구분됩니다.

## 특징

1. 공유 : 모든 인스턴스가 동일한 static 변수에 접근합니다. 따라서 데이터를 공유하거나 상태를 저장할 때 유용.

2. 클래스 수준의 변수 및 메서드 : static 변수와 메서드는 클래스 로드 시 메모리에 할당(객체가 생성할 떄가 아니라).


```java
// 일반 field에 미리 초기화를 해두는 방식 : 객체가 생성될 때마다 동일한 내용이 반복적으로 메모리에 할당됨.
@Setter
@Getter
public class KoreaItStudent12 extends KoreaItStudnet {

    // field 선언
    private String name;
    private int age;
    private String address;
    private String introduciton = "코리아 아이티 국비 과정 12월";
}

public class Main {
    public static void main(String[] args) {
        KoreaItStudent12 student1 = new KoreaItStudent12();
        student1.setName("김일");
        student1.setAge(20);
        student1.setAddress("부산광역시 부산진구");
        System.out.println(student.getIntrodiction());  // 결과값 : 코리아 아이티 국비 과정 12월    
    }
}
```

```java
// 정적 변수의 선언으로 클래스가 메모리에 마운트 될때 1 번 저장.
// 이후 객체가 생성될 때마다 동일한 introduction field를 가지게 됨.
@Setter
@Getter
public class KoreaItStudent12 extends KoreaItStudnet {
    // 정적 변수 선언
    private static String introduciton = "코리아 아이티 국비 과정 12월";

    // field 선언
    private String name;
    private int age;
    private String address;
    // private String introduciton = "코리아 아이티 국비 과정 12월";
}

public class Main {
    public static void main(String[] args) {
        KoreaItStudent12 student1 = new KoreaItStudent12();
        student1.setName("김일");
        student1.setAge(20);
        student1.setAddress("부산광역시 부산진구");
        System.out.println(student.getIntrodiction());  // 결과값 : 코리아 아이티 국비 과정 12월    
    }
}
```

이상의 KoreaItStudent12 클래스의 인스턴스들은 다 동일한 private static String '정적 변수'를 갖게 됩니다. 즉, 어느 클래스의 인스턴스인지만 확인하더라도 몇 월 국비생인지를 확인할 수 있겠네요.

3. 인스턴스가 필요없음 : 객체를 생성하지 않고도 클래스명.field / 클래스명.메서드명() 형태로 접근이 가능합니다(이때는 private이 아니어야겠네요)

4. 메모리 효율성 : static 변수는 프로그램이 종료될 때까지 한 번만 메모리에 할당됨(객체가 생성될 때마다가 아니라).

# Builder Pattern(빌더 패턴)

```java
@AllArgsConstructor
public clss Student {
    private int code;
    private String name;
    private String gender;
    private String school;
    private int semester;
    private String[] subjects;
    private double[] scores;
}
public class StudentMain {
    public static void main(String[] args) {
        Student student = new Student(여기 내부에 모든 field를 순서대로 작성해야합니다);
    }
}
```

## 빌더 패턴이 생기게 된 원인

1. 복잡한 생성자 문제

    - 객체의 field가 많아질 수록 생성자 매개변수 수도 늘어남.

        - 저희는 롬복 쓰니까 생성자 코드 라인이 적을 수 있지만

        - 필수적인 부분에 @NonNull이나 final을 써야하고, 그와중에 final 쓰면 기본 생성자는 못만드는 등 여러가지 제약이 있습니다.

2. 생성자 오버로딩 문제

    - 생성자에 필요한 조합이 다를 경우 수많은 생성자를 하나씩 정의해야 합니다.

        - 예를 들어 옛날 회원가입의 경우 집전화와 폰번호가 필수였는데, 오늘날에는 집전화는 optional인 상태죠. 그럼 처음에는 homePhone field를 넣어놨는데 나중에는 그거 삭제해야하고 하여튼 귀찮은 상황이 발생합니다.

    - 유지보수에 악영향 / 예를 들어서 field 하나 추가하면 AllArgsConstructor가 아니게 되니까 다 뜯어 고쳐야겠네요. 저희가 VolumeUpButton 추가했을 떄 생성자 뜯어내고 Main에서 생성자 호출할 때도 오류 수정했던 것을 떠올리면 되겠습니다.

3. 가득성 문제
    
    - 코드를 작성하고 읽는 입장에서는 객체를 생성할 떄 어떤 값이 어떤 field에 해당하는지 명확하지 않아서 실수를 유발할 수 있음.


```java
public static void main(String[] args) {
    Student student = new String("김일", "김이");
}
```
// 라고 했을 때 얘가 김일 학생인데 김이 초등학교인지 김일 초등학교인데 김이 학생인지 알바가 없다는 겁니다.

## 정의

- 객체의 생성과정에서 '복잡한 생성자'를 대신하여 '단계적으로' 객체를 생성할 수 있는 디자인 패턴 중 생성 파트 관련. GoF(Gang of four) 디자인 패턴 중 하나로 객체 생성 시 가독성과 유연성을 제공하는 것이 목표.

- 이상에서는 유연성의 의미는 field를 '순서대로' 채워넣지 않아도 되고, 순서를 바꾸더라도 정확한 field에 원하는 값을 집어넣을 수 있다느 것을 의미합니다.

## 특징

1. 객체를 생성하는 여러 개의 field를 '명시적'으로 관리할 수 있음.

2. 불필요한 생성자 오버로딩을 줄여 가독성을 높임.

3. 체이닝 메서드를 사용하여 객체를 직관적으로 생성

## 빌더 패턴 예시

```java
package ch17_static.builders;

import lombok.ToString;

@ToString
public class Person {
    private String name;
    private int age;
    private String address;

    private Person(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.address = builder.address;
    }

    public static class Builder {
        private String name;
        private int age;
        private String address;

        /*
            그러면 class 내에 static class라고 하는 것을 정의했는데,
            Builder 라고하는 static 클래스 내에 field들을 정의했습니다.
            근데 클래스니까 field와 method 들로 이루어져있겠네요.
            이하는 method들을 정의하는 영역이 됩니다. 이하의 부분이 builder pattern의 필수영역이 됩니다.
         */

        public Builder name(String name) {
            this.name = name;   // argument로 들어온 String data를 Builder의 field인 name에 대입
            return this;    // 그러면 name() 호출 전에는 field의 name에 값이 없다가 27 번 코드라인
            // 시점에 name field에 값이 들어간 상태에서 Builder 클래스의 객체가 return됩니다.
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        // address() 메서드를 정의하시오.
        public Builder address(String address) {
            this.address = address;
            return this;
        }

        /*
            field 명과 동일한 메서드들을 이상에서 정의했습니다.
            그리고 메서드가 호출된 결과로 Builder 객체에 field 값이 대입된 상태된 후에
            그 객체가 return 되는 형태입니다.
         */
        public Person build() {
            return new Person(this);
        }
    }
}

```

이 코드가 위와 같습니다.

```java
package ch17_static.builders;

import lombok.Builder;
import lombok.ToString;

@ToString
@Builder
public class Person2 {
    private String name;
    private int age;
    private String address;
}

```

```java
package ch17_static.builders;

public class PersonMain {
    public static void main(String[] args) {
//        Person person = new Person();
        /*
            private Person(Builder builder)로 정의한 매개변수 생성자만 있으니 기본 생성자가 없다는 점에서 오류 발생.
            그리고 private 접근 제어자기 때문에 () 내에 Builder 객체를 집어넣는다고 하더라도 오류 발생

            혹시 AllArgsConstructor 형태로 작성한다면
         */
//        Person person = new Person("김일", 20, "서울특별시 종로구");
        // 이상의 AllArgsConstructor를 Builder 패턴을 적용하여 객체 생성을 해보겠습니다.
        // 필드 순서를 다르게 집어넣었는데 만들어졌네요.
        Person person1 = new Person.Builder().age(21).address("부산광역시 부산진구").name("김일").build();
        System.out.println(person1);    // Person(name=김일, age=21, address=부산광역시 부산진구)

        // Builder 패턴을 활용한 NoArgsConstructor
        Person person2 = new Person.Builder().build();
        System.out.println(person2);    // Person(name=null, age=0, address=null)

        Person person3 = new Person.Builder().name("김삼").build();
        System.out.println(person3);    // Person(name=김삼, age=0, address=null)

        Person2 person4 = Person2.builder().name("김사").build();
        System.out.println(person4);    // Person2(name=김사, age=0, address=null)

        Person2 person5 = Person2.builder().build();
        System.out.println(person5);    // Person2(name=null, age=0, address=null)

        Person2 person6 = Person2.builder()
                .age(26)
                .name("김육")
                .address("광주광역시 북구")
                .build();
        System.out.println(person6);    // Person2(name=김육, age=26, address=광주광역시 북구)
    }
}

```